{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chowda","text":"<p>A CLAMS processing app</p>"},{"location":"#install","title":"Install","text":"<p>Install instructions can be found on the install page</p>"},{"location":"#reference","title":"Reference","text":"<p>Further details can be found in the reference section</p>"},{"location":"#credits","title":"Credits","text":"<p>Created by WGBH-MLA for the CLAMS project</p>"},{"location":"install/","title":"Install","text":""},{"location":"install/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/WGBH-MLA/chowda.git\ncd chowda\n</code></pre>"},{"location":"install/#install-chowda","title":"Install Chowda","text":""},{"location":"install/#option-1-install-with-pdm-recommended","title":"Option 1: Install with PDM (Recommended)","text":"<p>PDM is used as the packaging manager. It can be installed with <code>pip install pdm</code>.</p> <p>Install the project with development dependencies:</p> <pre><code>pdm install\n</code></pre> <p>Activate your virtual environment</p> <pre><code>$(pdm venv activate)\n</code></pre> $() wrapper <p>Note: <code>pdm venv activate</code> outputs the command needed to activate your virtual environment. The <code>$()</code> wrapper evaluates it in your current shell context.</p> Deactivate the virtual environment <p>To return to your normal shell environment, run:</p> <pre><code>deactivate\n</code></pre>"},{"location":"install/#option-2-install-with-pip","title":"Option 2: Install with pip","text":"<p>If PDM is not available, it can also be installed with pip. It is recommeneded to install to a virtual environment using <code>venv</code>:</p> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>Install the package</p> <pre><code>pip install .\n</code></pre>"},{"location":"install/#create-database","title":"Create database","text":"<p>Chowda needs to have a PostgreSQL server running and database named <code>chowda-development</code> (tests use a database <code>chowda-test</code>).</p> <p>There are many ways to do this, but an easy way is to use docker. After starting Docker on your local machine, the following command will start a container using the <code>postgres</code> image in Dockerhub.</p> <pre><code>docker run --rm --name pg -p 5432:5432 -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=chowda-development postgres\n</code></pre>"},{"location":"install/#command-explained","title":"Command explained","text":"<ul> <li><code>docker run</code> runs a docker container</li> <li><code>--rm</code> option will remove the docker container once it exits.</li> <li><code>--name pg</code> will name the running container <code>pg</code> so it can be identified when listing running containers.</li> <li><code>-p 5432:5432</code> forwards port 5432 on your local machine to port 5432 (default postgres port) on the running container.</li> <li><code>-e POSTGRES_USER=postgres</code> sets ENV var on container for the postgres username</li> </ul> <p>Security</p> <p>Not a secure password, but that's ok for test and development environments.</p> <ul> <li><code>-e POSTGRES_PASSWORD=postgres</code> sets ENV var on container for postgres password</li> </ul> <p><code>DB_URL</code> environment variable</p> <p>the environment variables values in the command must match the values that are part of the <code>DB_URL</code> environment variable specified in <code>.env.development</code>.</p> <ul> <li><code>-e POSTGRES_DB=chowda-development</code> sets ENV var on container for the name of postgres database to use</li> </ul> <p>Database creation in docker</p> <p>The <code>postgres</code> image will create the database when starting the container.</p> <ul> <li><code>postgres</code> is the name of the Docker image to use when starting the container.</li> </ul>"},{"location":"install/#apply-database-migrations","title":"Apply database migrations","text":"<pre><code>alembic upgrade head\n</code></pre>"},{"location":"install/#run-the-application","title":"Run the application","text":"<p>The development server can be run with</p> <pre><code>pdm dev\n</code></pre> <p>Which is a shortcut for:</p> <pre><code>uvicorn chowda.app:app --reload\n</code></pre> <p>Visit: localhost:8000</p>"},{"location":"install/#seed-the-database","title":"Seed the database","text":"<p>To seed the database with fake data, run the <code>seeds.py</code> script:</p> <pre><code>python tests/seeds.py\n</code></pre> <p>Optional: Customize the number of records created by changing the <code>num_*</code> variables in the <code>seed</code> function.</p>"},{"location":"install/#running-tests","title":"Running tests","text":"<p>Chowda uses <code>pytest</code> for testing. Simply run:</p> <pre><code>pdm test\n</code></pre> <p>Which is the same as running:</p> <pre><code>pytest\n</code></pre>"},{"location":"install/#creating-the-test-database-and-running-a-postgres-server","title":"Creating the test database and running a postgres server","text":"<p>For the tests to run successfully, it needs a dedicated test database. This can be done with docker, with the following command:</p> <pre><code>docker run --rm --name pg -p 5432:5432 -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=chowda-test postgres\n</code></pre>"},{"location":"examples/Argo/","title":"Argo Events","text":"In\u00a0[1]: Copied! <pre>from metaflow import namespace\nfrom metaflow.integrations import ArgoEvent\n</pre> from metaflow import namespace from metaflow.integrations import ArgoEvent In\u00a0[2]: Copied! <pre>namespace(\"triggerpipeline-0-vqms\")\n</pre> namespace(\"triggerpipeline-0-vqms\") Out[2]: <pre>'triggerpipeline-0-vqms'</pre> In\u00a0[4]: Copied! <pre>e = ArgoEvent(\n    \"ampersand\",\n    payload={\"guid\": \"1234\", \"pipeline\": \"http://app-name?params=true&amp;test=1\"},\n)\n</pre> e = ArgoEvent(     \"ampersand\",     payload={\"guid\": \"1234\", \"pipeline\": \"http://app-name?params=true&amp;test=1\"}, ) In\u00a0[5]: Copied! <pre>e.publish()\n</pre> e.publish() <pre>Argo Event (ampersand) published.\n</pre> Out[5]: <pre>'e9d3168d-349b-438c-8542-040017e1da72'</pre>"},{"location":"examples/Argo/#argo-events","title":"Argo Events\u00b6","text":"<p>This demonstrates how to use Argo Events to trigger a workflow.</p>"},{"location":"examples/Argo/#port","title":"Port\u00b6","text":"<p>Port forward to the argo-events <code>webhook</code> eventsource service:</p> <pre>kubectl -n argo-events port-forward service/webhook-eventsource-svc 12000\n</pre>"},{"location":"examples/__init__/","title":"init","text":""},{"location":"examples/events/","title":"Events","text":"In\u00a0[1]: Copied! <pre>from metaflow.integrations import ArgoEvent\n\nsync = ArgoEvent('sync')\n\n# trigger the event with publish()\n# sync.publish()\n</pre> from metaflow.integrations import ArgoEvent  sync = ArgoEvent('sync')  # trigger the event with publish() # sync.publish()"},{"location":"examples/events/#events","title":"Events\u00b6","text":"<p>Use Argo Events to trigger workflows.</p>"},{"location":"examples/events/#setup","title":"Setup\u00b6","text":"<p>Configure Metaflow to connect to Argo Events.</p> <pre>{\n    \"METAFLOW_ARGO_EVENTS_EVENT\": \"chowda\",\n    \"METAFLOW_ARGO_EVENTS_EVENT_BUS\": \"default\",\n    \"METAFLOW_ARGO_EVENTS_EVENT_SOURCE\": \"webhook\",\n    \"METAFLOW_ARGO_EVENTS_INTERNAL_WEBHOOK_URL\": \"http://webhook-eventsource-svc.argo-events.svc.cluster.local:12000\",\n    \"METAFLOW_ARGO_EVENTS_WEBHOOK_URL\": \"http://localhost:12000/chowda\",\n    \"METAFLOW_ARGO_EVENTS_SERVICE_ACCOUNT\": \"operate-workflow-sa\",\n    ...\n}\n</pre> <p>If running locally, port-forward the webhook event source.</p> <pre>kubectl port-forward svc/webhook-eventsource-svc 12000:12000\n</pre>"},{"location":"examples/events/#sync","title":"Sync\u00b6","text":"<p>Trigger the <code>IngestFlow</code> to sync all assets from SonyCi to the Chowda database.</p>"},{"location":"examples/guids/","title":"Resolve filenames to GUIDs","text":"In\u00a0[3]: Copied! <pre>from chowda.db import engine\nfrom chowda.models import SonyCiAsset\nfrom sqlmodel import Session, select\nfrom re import search, split\n\n\ndef get_asset():\n    with Session(engine) as session:\n        statement = select(SonyCiAsset)\n        results = session.exec(statement)\n\n        return [\n            (asset.id, split('_|\\.|-dupe', asset.name)[0])\n            for asset in results.all()\n            if search('^cpb-aacip-', asset.name)\n        ]\n\n\n# assets = get_asset()\n</pre> from chowda.db import engine from chowda.models import SonyCiAsset from sqlmodel import Session, select from re import search, split   def get_asset():     with Session(engine) as session:         statement = select(SonyCiAsset)         results = session.exec(statement)          return [             (asset.id, split('_|\\.|-dupe', asset.name)[0])             for asset in results.all()             if search('^cpb-aacip-', asset.name)         ]   # assets = get_asset()  In\u00a0[4]: Copied! <pre># len(assets)\n\n\ndef write_assets():\n    with open('guids.txt', 'w') as f:\n        for asset in assets:\n            f.write(f'{asset[1]}\\n')\n</pre> # len(assets)   def write_assets():     with open('guids.txt', 'w') as f:         for asset in assets:             f.write(f'{asset[1]}\\n') In\u00a0[6]: Copied! <pre>from chowda.models import MediaFile\n\n\ndef insert_media_files():\n    with Session(engine) as session:\n        for asset in assets:\n            # Extract the GUID name\n            guid = split(r'_|\\.|-dupe', asset[1])[0]\n            # media_file = session.get(MediaFile, guid)\n            media_file = session.exec(\n                select(MediaFile).where(MediaFile.guid == guid)\n            ).first()\n            if not media_file:\n                # Create a new MediaFile with the new guid\n                media_file = MediaFile(guid=guid)\n                # session.add(media_file)\n            ci_asset = session.get(SonyCiAsset, asset[0])\n            # Add the asset to the existing MediaFile\n            media_file.assets.append(ci_asset)\n            # asset.media_files.append(media_file)\n            session.add(media_file)\n        session.commit()\n</pre> from chowda.models import MediaFile   def insert_media_files():     with Session(engine) as session:         for asset in assets:             # Extract the GUID name             guid = split(r'_|\\.|-dupe', asset[1])[0]             # media_file = session.get(MediaFile, guid)             media_file = session.exec(                 select(MediaFile).where(MediaFile.guid == guid)             ).first()             if not media_file:                 # Create a new MediaFile with the new guid                 media_file = MediaFile(guid=guid)                 # session.add(media_file)             ci_asset = session.get(SonyCiAsset, asset[0])             # Add the asset to the existing MediaFile             media_file.assets.append(ci_asset)             # asset.media_files.append(media_file)             session.add(media_file)         session.commit()"},{"location":"examples/guids/#resolve-filenames-to-guids","title":"Resolve filenames to GUIDs\u00b6","text":"<p>In order to address MediaFiles by GUIDs, we need to extract the GUID from the <code>SonyCiAsset.name</code> field.</p>"},{"location":"examples/guids/#steps","title":"Steps\u00b6","text":"<ol> <li>Get the list of assets from the DB</li> <li>Filter out any name that does not start with <code>cpb-aacip-</code></li> <li>Split the name on any of:<ul> <li><code>_</code> underscore</li> <li><code>.</code> period</li> <li><code>-dupe</code></li> </ul> </li> </ol> <p>There are 8 records with <code>-dupe</code> in the name. All other records are correctly filtered with <code>_</code> and <code>.</code>.</p>"},{"location":"examples/guids/#check-the-list","title":"Check the list\u00b6","text":"<p>If needed, write the guid list to a file and check it manually.</p>"},{"location":"examples/guids/#insert-mediafiles","title":"Insert MediaFiles\u00b6","text":"<p>Iterate through the list of assets:</p> <ul> <li>Split the GUID from the filename.</li> <li>Search the database for a matching MediaFile object.<ul> <li>Insert a new MediaFile object if it does not already exist.</li> </ul> </li> <li>Find the SonyCiAsset object in the database.</li> <li>Link the MediaFile object to the SonyCiAsset object.</li> </ul>"},{"location":"examples/session/","title":"SQLModel Session exercise","text":"In\u00a0[1]: Copied! <pre>from chowda.db import init_db\nfrom tests.factories import *\ninit_db()\n</pre> from chowda.db import init_db from tests.factories import * init_db() In\u00a0[2]: Copied! <pre>batch = BatchFactory.create()\n</pre> batch = BatchFactory.create() In\u00a0[3]: Copied! <pre>from sqlmodel import Session\n\nsession = Session.object_session(batch)\n</pre> from sqlmodel import Session  session = Session.object_session(batch) In\u00a0[4]: Copied! <pre>batch.description = \"exceedingly jolly\"\n</pre> batch.description = \"exceedingly jolly\" In\u00a0[5]: Copied! <pre>print('session.dirty = ', session.dirty)\n# =&gt; session.dirty = IdentitySet([Batch(description='foo')])\n</pre> print('session.dirty = ', session.dirty) # =&gt; session.dirty = IdentitySet([Batch(description='foo')]) <pre>session.dirty =  IdentitySet([Batch(description='exceedingly jolly')])\n</pre> In\u00a0[6]: Copied! <pre>session.commit()\n</pre> session.commit() In\u00a0[7]: Copied! <pre>print('session.dirty = ', session.dirty)\n# =&gt; IdentitySet([])\n</pre> print('session.dirty = ', session.dirty) # =&gt; IdentitySet([]) <pre>session.dirty =  IdentitySet([])\n</pre> In\u00a0[19]: Copied! <pre>from sqlmodel import select\n\nwith Session(engine) as db:\n    batch_copy = db.exec(select(Batch).where(Batch.id == batch.id)).first()\nprint('batch_copy.description = ', batch_copy.description)\n# =&gt; foo\n</pre> from sqlmodel import select  with Session(engine) as db:     batch_copy = db.exec(select(Batch).where(Batch.id == batch.id)).first() print('batch_copy.description = ', batch_copy.description) # =&gt; foo <pre>batch_copy.description =  exceedingly jolly and effortlessly charming and elaborately loquacious\n</pre> <p>Note that since we grabbed batch_copy using a contextual session, and that context has ended, so has the session, and the object is currently unattached to any session.</p> In\u00a0[20]: Copied! <pre>print('seesion for batch_copy = ', Session.object_session(batch_copy))\n# =&gt; None\n</pre> print('seesion for batch_copy = ', Session.object_session(batch_copy)) # =&gt; None <pre>seesion for batch_copy =  None\n</pre> In\u00a0[12]: Copied! <pre>batch_copy.description += \" and effortlessly charming\"\nwith Session(engine) as db:\n    db.add(batch_copy)\n    db.commit()\n</pre> batch_copy.description += \" and effortlessly charming\" with Session(engine) as db:     db.add(batch_copy)     db.commit()  In\u00a0[13]: Copied! <pre>with Session(engine) as db:\n    db.add(batch_copy)\n    print('batch_copy.description = ', batch_copy.description)\n    # =&gt; batch_copy.description =  exceedingly jolly and effortlessly charming\n</pre> with Session(engine) as db:     db.add(batch_copy)     print('batch_copy.description = ', batch_copy.description)     # =&gt; batch_copy.description =  exceedingly jolly and effortlessly charming  <pre>batch_copy.description =  exceedingly jolly and effortlessly charming\n</pre> In\u00a0[14]: Copied! <pre>print('batch.description before refresh = ', batch.description)\n# =&gt; batch.description before refresh = exceedingly jolly\n</pre> print('batch.description before refresh = ', batch.description) # =&gt; batch.description before refresh = exceedingly jolly  <pre>batch.description before refresh =  exceedingly jolly\n</pre> In\u00a0[15]: Copied! <pre>session.refresh(batch)\nprint('batch.description after refresh = ', batch.description)\n# =&gt; batch.description after refresh = exceedingly jolly and effortlessly charming\n</pre> session.refresh(batch) print('batch.description after refresh = ', batch.description) # =&gt; batch.description after refresh = exceedingly jolly and effortlessly charming  <pre>batch.description after refresh =  exceedingly jolly and effortlessly charming\n</pre> In\u00a0[16]: Copied! <pre>batch.description += \" and fantastically flatulent\"\n</pre> batch.description += \" and fantastically flatulent\" In\u00a0[17]: Copied! <pre>session.commit()\n</pre> session.commit()  In\u00a0[18]: Copied! <pre>with Session(engine) as db:\n    batch_copy.description += \" and elaborately loquacious\"\n    db.add(batch_copy)\n    db.commit()\n    print('batch_copy.description = ', batch_copy.description)\n# =&gt; batch_copy.description =  exceedingly jolly and effortlessly charming and elaborately loquacious\n</pre> with Session(engine) as db:     batch_copy.description += \" and elaborately loquacious\"     db.add(batch_copy)     db.commit()     print('batch_copy.description = ', batch_copy.description) # =&gt; batch_copy.description =  exceedingly jolly and effortlessly charming and elaborately loquacious  <pre>batch_copy.description =  exceedingly jolly and effortlessly charming and elaborately loquacious\n</pre>"},{"location":"examples/session/#sqlmodel-session-exercise","title":"SQLModel Session exercise\u00b6","text":"<p>Adapted from Drew's slack example</p>"},{"location":"examples/session/#create-a-new-batch-from-factory","title":"Create a new Batch from factory\u00b6","text":""},{"location":"examples/session/#grab-the-session-the-batch-was-created-with-for-inspection","title":"Grab the session the Batch was created with for inspection.\u00b6","text":""},{"location":"examples/session/#change-something-on-the-batch","title":"Change something on the batch\u00b6","text":""},{"location":"examples/session/#view-the-changes-that-have-yet-to-be-committed-to-the-db","title":"View the changes that have yet to be committed to the db\u00b6","text":""},{"location":"examples/session/#commit-the-changes-to-the-db","title":"Commit the changes to the db.\u00b6","text":"<p>Note that we do not have to call session.add(batch) since the Batch instance is already attached to the session.</p>"},{"location":"examples/session/#verify-there-are-no-other-pending-changes","title":"Verify there are no other pending changes.\u00b6","text":""},{"location":"examples/session/#use-a-contextual-session","title":"Use a contextual session\u00b6","text":"<p>(called \"db\") to grab a separate copy of the batch and verify it has the change.</p>"},{"location":"examples/session/#now-change-batch_copydescripiton","title":"Now change batch_copy.descripiton,\u00b6","text":"<p>save it with a contextual session, and see how it affected or original Batch instance, which is still alive and attached to the session it was created with.</p>"},{"location":"examples/session/#note-after-committing-changes-to-batch_copy-using-contextual-session-in-this-way","title":"NOTE: after committing changes to batch_copy using contextual session in this way,\u00b6","text":"<p>trying to access attributes on the object like batch_copy.description raises an error:</p> <p>Instance &lt;Batch at 0x107b84e10&gt; is not bound to a Session; attribute refresh operation cannot proceed</p>"},{"location":"examples/session/#confirm-that-our-original-batch-instance-still-has-the-old-description","title":"Confirm that our original Batch instance still has the old description\u00b6","text":""},{"location":"examples/session/#refresh-the-original-batch-instance","title":"Refresh the original Batch instance\u00b6","text":"<p>and check the description again</p>"},{"location":"examples/session/#now-lets-edit-batchdescription-and-batch_copydescription","title":"Now let's edit <code>batch.description</code> and <code>batch_copy.description</code>\u00b6","text":"<p>and update them both independently to see what happens.</p>"},{"location":"examples/session/#save-the-first-edit","title":"save the first edit\u00b6","text":""},{"location":"examples/session/#save-the-second-edit","title":"save the second edit\u00b6","text":""},{"location":"examples/session/#unsurprisingly-the-2nd-save-wins","title":"Unsurprisingly, the 2nd save wins.\u00b6","text":"<p>The changes saved in original Batch instance with it's original session get overwritten by this one.</p>"},{"location":"examples/upsert/","title":"Upsert","text":"In\u00a0[1]: Copied! <pre>from sqlmodel import Session, select\n\nfrom chowda.models import SonyCiAsset\nfrom chowda.db import engine\n</pre> from sqlmodel import Session, select  from chowda.models import SonyCiAsset from chowda.db import engine  In\u00a0[2]: Copied! <pre>def get_asset():\n    with Session(engine) as session:\n        z = session.exec(select(SonyCiAsset).where(SonyCiAsset.id == 'test'))\n\n        x = z.first()\n</pre> def get_asset():     with Session(engine) as session:         z = session.exec(select(SonyCiAsset).where(SonyCiAsset.id == 'test'))          x = z.first() In\u00a0[3]: Copied! <pre>from sqlalchemy.dialects.postgresql import insert\n\nc = SonyCiAsset(\n    id='test',\n    name='testname',\n    type='Video',\n    size=1,\n    format='mp4',\n    thumbnails=[],\n)\nc.model_dump()\n</pre> from sqlalchemy.dialects.postgresql import insert  c = SonyCiAsset(     id='test',     name='testname',     type='Video',     size=1,     format='mp4',     thumbnails=[], ) c.model_dump() Out[3]: <pre>{'name': 'testname',\n 'size': 1,\n 'type': &lt;MediaType.video: 'Video'&gt;,\n 'format': 'mp4',\n 'thumbnails': []}</pre> In\u00a0[4]: Copied! <pre>def upsert(asset):\n    with Session(engine) as session:\n        stmt = (\n            insert(SonyCiAsset)\n            .values([asset])\n            .on_conflict_do_update(\n                index_elements=[SonyCiAsset.id],\n                set_=asset,\n            )\n        )\n        session.execute(stmt)\n        session.commit()\n</pre> def upsert(asset):     with Session(engine) as session:         stmt = (             insert(SonyCiAsset)             .values([asset])             .on_conflict_do_update(                 index_elements=[SonyCiAsset.id],                 set_=asset,             )         )         session.execute(stmt)         session.commit()"},{"location":"reference/","title":"Reference","text":"<p>This section describes the implementation of specific code modules.</p>"},{"location":"reference/#modules","title":"Modules","text":"<ul> <li>app - the main web application</li> <li>models - Database models</li> </ul>"},{"location":"reference/#database","title":"Database","text":"<ul> <li>Database Management - Migrations with Alembic</li> </ul>"},{"location":"reference/#deploy","title":"Deploy","text":"<ul> <li>Deploy - Deploying to a production kubernetes environment</li> </ul>"},{"location":"reference/app/","title":"App","text":"<p>App</p> <p>Main Chowda application</p>"},{"location":"reference/database/","title":"Database Management","text":""},{"location":"reference/database/#migrations-with-alembic","title":"Migrations with Alembic","text":"<p>Chowda uses Alembic, a migration tool for the SQLAlchemy, which is the database ORM used by SQLModel.</p>"},{"location":"reference/database/#creating-migrations","title":"Creating migrations","text":"<p>Chowda's models inherit from <code>SQLModel</code> and if the <code>table=True</code> parameter is passed, then the model is for representing data stored in a database table. For these models to work correctly, the underlying table needs to match the <code>SQLModel</code> definition in python code, and this is where migrations come in.</p> <p>Alembic can detect the differences between Chowda's models and the underlying databse schema and then generate a migration script to change the database to match the model.</p> <p>After you have made the changes to your model classes, run the following command from the command line:</p> <pre><code>alembic revision --autogenerate -m \"short_desc_of_model_changes\"\n</code></pre> <p>This will generate a migration script under <code>migrations/revision</code>. The script name will be an random ID for the revision followed by the value of the <code>-m</code> flag, e.g. <code>480b8fe17026_short_desc_of_db_change.py</code>.</p> <p>Migration files</p> <p>After a migration is run, the revision ID in the file name is stored in the <code>alembic_version</code> table that is added to the database when Alembic is first installed. This table is what tells Alembic whether there are migrations to run or not.</p>"},{"location":"reference/database/#checking-to-see-if-there-are-any-migrations-to-run","title":"Checking to see if there are any migrations to run","text":"<p>From the command line run:</p> <pre><code>alembic check\n</code></pre> <p>If there are no migrations to run, you should see:</p> <pre><code>No new upgrade operations detected.\n</code></pre> <p>If there are migrations to run, you should see:</p> <pre><code>ERROR [alembic.util.messaging] Target database is not up to date.\n  FAILED: Target database is not up to date.\n</code></pre>"},{"location":"reference/database/#run-migrations","title":"Run migrations","text":"<p>From the command line run:</p> <pre><code>alembic upgrade head\n</code></pre> <p>This will run all migrations that haven't yet been run. If there were no migrations that needed to run, nothing will happen.</p>"},{"location":"reference/deploy/","title":"Deploy","text":"<p>This section describes how to deploy Chowda to a production kubernetes environment.</p>"},{"location":"reference/deploy/#todo","title":"TODO","text":"<ul> <li>[ ] Add instructions for deploying to a kubernetes environment</li> </ul>"},{"location":"reference/models/","title":"Models","text":"<p>Models</p> <p>SQLModels for DB and validation</p>"},{"location":"reference/models/#chowda.models.Batch","title":"<code>Batch</code>","text":"<p>             Bases: <code>SQLModel</code></p> Source code in <code>chowda/models.py</code> <pre><code>class Batch(SQLModel, table=True):\n    __tablename__ = 'batches'\n    id: Optional[int] = Field(primary_key=True, default=None)\n    name: str\n    description: str\n    pipeline_id: Optional[int] = Field(default=None, foreign_key='pipelines.id')\n    pipeline: Optional['Pipeline'] = Relationship(back_populates='batches')\n    media_files: List[MediaFile] = Relationship(\n        back_populates='batches', link_model=MediaFileBatchLink\n    )\n    output_mmifs: List['MMIF'] = Relationship(\n        back_populates='batch_output',\n        sa_relationship_kwargs={\n            \"primaryjoin\": \"Batch.id==MMIF.batch_output_id\",\n        },\n    )\n\n    input_mmifs: List['MMIF'] = Relationship(\n        back_populates='batch_inputs',\n        link_model=MMIFBatchInputLink,\n    )\n    metaflow_runs: List['MetaflowRun'] = Relationship(back_populates='batch')\n\n    def unstarted_guids(self) -&gt; set:\n        \"\"\"Returns the set of GUIDs that are not currently running\"\"\"\n        ids: set = {media_file.guid for media_file in self.media_files}\n        running_guids: set = {run.media_file.guid for run in self.metaflow_runs}\n        return ids - running_guids\n\n    async def __admin_repr__(self, request: Request) -&gt; str:\n        return f'{self.name or self.id}'\n\n    async def __admin_select2_repr__(self, request: Request) -&gt; str:\n        return f'&lt;span&gt;&lt;strong&gt;{self.name or self.id}&lt;/span&gt;'\n</code></pre>"},{"location":"reference/models/#chowda.models.Batch.unstarted_guids","title":"<code>unstarted_guids()</code>","text":"<p>Returns the set of GUIDs that are not currently running</p> Source code in <code>chowda/models.py</code> <pre><code>def unstarted_guids(self) -&gt; set:\n    \"\"\"Returns the set of GUIDs that are not currently running\"\"\"\n    ids: set = {media_file.guid for media_file in self.media_files}\n    running_guids: set = {run.media_file.guid for run in self.metaflow_runs}\n    return ids - running_guids\n</code></pre>"},{"location":"reference/models/#chowda.models.MMIF","title":"<code>MMIF</code>","text":"<p>             Bases: <code>SQLModel</code></p> <p>MMIF model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[int]</code> <p>Primary key</p> <code>created_at</code> <code>Optional[datetime]</code> <p>Creation timestamp</p> <code>media_file_id</code> <code>Optional[str]</code> <p>GUID</p> <code>media_file</code> <code>Optional[MediaFile]</code> <p>MediaFile</p> <code>metaflow_run_id</code> <code>Optional[str]</code> <p>MetaflowRun ID</p> <code>metaflow_run</code> <code>Optional[MetaflowRun]</code> <p>MetaflowRun</p> <code>batch_output</code> <code>Optional[Batch]</code> <p>Batch that generated this MMIF</p> <code>batch_inputs</code> <code>List[Batch]</code> <p>Batch that uses this as an input</p> Source code in <code>chowda/models.py</code> <pre><code>class MMIF(SQLModel, table=True):\n    \"\"\"MMIF model\n\n    Attributes:\n        id: Primary key\n        created_at: Creation timestamp\n        media_file_id: GUID\n        media_file: MediaFile\n        metaflow_run_id: MetaflowRun ID\n        metaflow_run: MetaflowRun\n        batch_output: Batch that generated this MMIF\n        batch_inputs: Batch that uses this as an input\n    \"\"\"\n\n    __tablename__ = 'mmifs'\n    id: Optional[int] = Field(primary_key=True, default=None, index=True)\n    created_at: Optional[datetime] = Field(\n        sa_column=Column(DateTime(timezone=True), default=datetime.utcnow)\n    )\n    media_file_id: Optional[str] = Field(\n        default=None, foreign_key='media_files.guid', index=True\n    )\n    media_file: Optional[MediaFile] = Relationship(back_populates='mmifs')\n    metaflow_run_id: Optional[str] = Field(default=None, foreign_key='metaflow_runs.id')\n    metaflow_run: Optional[MetaflowRun] = Relationship(back_populates='mmif')\n    batch_output_id: Optional[int] = Field(default=None, foreign_key='batches.id')\n    batch_output: Optional[Batch] = Relationship(\n        back_populates='output_mmifs',\n        sa_relationship_kwargs={\n            \"primaryjoin\": \"MMIF.batch_output_id==Batch.id\",\n        },\n    )\n    batch_inputs: List[Batch] = Relationship(\n        back_populates='input_mmifs',\n        link_model=MMIFBatchInputLink,\n    )\n\n    mmif_location: Optional[str] = Field(default=None)\n\n    async def __admin_repr__(self, request: Request):\n        return (\n            f'{self.metaflow_run.batch.name}'\n            if self.metaflow_run and self.metaflow_run.batch\n            else self.id\n        )\n\n    async def __admin_select2_repr__(self, request: Request) -&gt; str:\n        text = (\n            self.metaflow_run.batch.name\n            if self.metaflow_run and self.metaflow_run.batch\n            else self.id\n        )\n        return f'&lt;span&gt;{text}&lt;/span&gt;'\n</code></pre>"},{"location":"reference/models/#chowda.models.MediaFile","title":"<code>MediaFile</code>","text":"<p>             Bases: <code>SQLModel</code></p> <p>Media file model</p> <p>Attributes:</p> Name Type Description <code>guid</code> <code>Optional[str]</code> <p>MediaFile GUID</p> <code>assets</code> <code>List[SonyCiAsset]</code> <p>List of SonyCiAssets</p> <code>collections</code> <code>List[Collection]</code> <p>List of Collections</p> <code>batches</code> <code>List[Batch]</code> <p>List of Batches</p> <code>metaflow_runs</code> <code>List[MetaflowRun]</code> <p>List of MetaflowRuns</p> <code>mmifs</code> <code>List[MMIF]</code> <p>List of MMIFs</p> Source code in <code>chowda/models.py</code> <pre><code>class MediaFile(SQLModel, table=True):\n    \"\"\"Media file model\n\n    Attributes:\n        guid: MediaFile GUID\n        assets: List of SonyCiAssets\n        collections: List of Collections\n        batches: List of Batches\n        metaflow_runs: List of MetaflowRuns\n        mmifs: List of MMIFs\n    \"\"\"\n\n    __tablename__ = 'media_files'\n    guid: Optional[str] = Field(primary_key=True, default=None, index=True)\n    mmifs: List['MMIF'] = Relationship(back_populates='media_file')\n    assets: List['SonyCiAsset'] = Relationship(back_populates='media_files')\n    collections: List['Collection'] = Relationship(\n        back_populates='media_files', link_model=MediaFileCollectionLink\n    )\n    batches: List['Batch'] = Relationship(\n        back_populates='media_files', link_model=MediaFileBatchLink\n    )\n    metaflow_runs: List['MetaflowRun'] = Relationship(back_populates='media_file')\n\n    def metaflow_runs_for_batch(self, batch_id: int):\n        return [\n            metaflow_run\n            for metaflow_run in self.metaflow_runs\n            if metaflow_run.batch_id == batch_id\n        ]\n\n    def last_metaflow_run_for_batch(self, batch_id: int):\n        # TODO: is getting the last one sufficient, or do we need to add sortable\n        # timestamps?\n        runs = self.metaflow_runs_for_batch(batch_id=batch_id)\n        return runs[-1] if len(runs) &gt; 0 else None\n\n    async def __admin_repr__(self, request: Request):\n        return self.guid\n\n    async def __admin_select2_repr__(self, request: Request) -&gt; str:\n        return f'&lt;span&gt;&lt;strong&gt;{self.guid}&lt;/strong&gt;&lt;/span&gt;'\n</code></pre>"},{"location":"reference/models/#chowda.models.MediaType","title":"<code>MediaType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Media type enum Type of Media: video or audio. This is not the same as the format of the media file.</p>"},{"location":"reference/models/#chowda.models.MediaType--fixme","title":"FIXME:","text":"<p>Enum class attributes are the values that are stored in the database. The value of the class attribute is the value returned by SonyCi (for validation) But starlette-admin + SQLAlchemy send the value to the db, not the name. Therefore, we need to Capatalize the name to make it match the db value.</p> Source code in <code>chowda/models.py</code> <pre><code>class MediaType(enum.Enum):\n    \"\"\"Media type enum\n    Type of Media: video or audio.\n    This is not the same as the format of the media file.\n\n    # FIXME:\n    Enum class attributes are the values that are stored in the database.\n    The value of the class attribute is the value returned by SonyCi (for validation)\n    But starlette-admin + SQLAlchemy send the value to the db, not the name.\n    Therefore, we need to Capatalize the name to make it match the db value.\n    \"\"\"\n\n    Video = 'Video'\n    Audio = 'Audio'\n</code></pre>"},{"location":"reference/models/#chowda.models.User","title":"<code>User</code>","text":"<p>             Bases: <code>SQLModel</code></p> <p>User model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>Optional[int]</code> <p>Primary key</p> <code>email</code> <code>EmailStr</code> <p>User email</p> <code>first_name</code> <code>str</code> <p>User first name</p> <code>last_name</code> <code>str</code> <p>User last name</p> Source code in <code>chowda/models.py</code> <pre><code>class User(SQLModel, table=True):\n    \"\"\"User model\n\n    Attributes:\n        id: Primary key\n        email: User email\n        first_name: User first name\n        last_name: User last name\n    \"\"\"\n\n    __tablename__ = 'users'\n    id: Optional[int] = Field(primary_key=True)\n    email: EmailStr = Field(unique=True, index=True, sa_type=AutoString)\n    first_name: str = Field(min_length=3, index=True)\n    last_name: str = Field(min_length=3, index=True)\n\n    async def __admin_repr__(self, request: Request):\n        return f'{self.first_name} {self.last_name}'\n</code></pre>"}]}